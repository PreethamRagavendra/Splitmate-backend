
Two types:

Type 1: axisType of 'y' and axisType of "exception": Single Color
Type 2: axisType of 'timeline': Multi Color


1) When ever activePayloadPropertyList is updated with new properties assignDefaultVisualsActionAtom will be triggered with activePayloadPropertyList as payload

2) Inside the assignDefaultVisualsActionSetter of assignDefaultVisualsActionAtom, if no activePayloadPropertyList is there return from triggering further steps

3) If activePayloadPropertyList is available proceed

4) Create empty localPropertyVisualSettings

4) Loop through the activePayloadPropertyList and check against _propertyVisualSettingsAtom. 

	4.1) If if of Property type definition is available inside _propertyVisualSettingsAtom: 
		4.1.1) Collect all and pass the visual settings and use combinationToIndex to update the usedIndexes in the service instance, if the combination isn't available ignore updating in usedIndexes
		4.1.2) Update those visuals inside empty against property id
	4.2) If property id is not available inside _propertyVisualSettingsAtom: 
		4.2.1) Collect them for further procedure

5) Loop through filtered properties from step 4 and check if each property has a attribute called defaultVisuals:
	
	5.1) If Property Object contains defaultVisuals: 
		5.1.1) Collect all and pass the visual settings and use combinationToIndex to update the usedIndexes in the service instance, if the combination isn't available ignore updating in usedIndexes
		5.1.2) Update those visuals inside empty against property id
	5.2) If Property object doesn't contain defaultVisuals:
		5.2.1) Collect them for further procedure

6) Loop through filtered properties from step 5
	
	Note: This step will be dependent on chartSettings which will be based on propertyKey.


If while looping:

If type 1: 

Check if propertie's: propertyKey has default chart settings in chart Settings response, 
	If available: pick the first color, and check if that combination is valid
		If valid: Check if visual combination is already picked or noy
			If picked: Ignore and collect the property for further processing
			If not picked: Add the visual settings for that id in localProeprtyVisual settings and added it to usedIndexes
		If not valid: Add the visual Settings for that id in localPropertyVisualSettings
	If not available: Collect the Property for further processing

If type 2:

Check if propertie's: propertyKey has default chart settings in chart Settings response, 
	If available: Assign it to MultiStateColorConfigType of property
	If not available: Collect the property for further processing

7) Separate type 1 properties and type 2 properties for collected properties which needs processing

8) For Type 1 properties use chart bucket: Loop through the properties, and assign visual settings using used: set<number> free: MinHeap<number> Implemebt reusable min heap and nex Index

9) For Type 2 properties use chart bucket: Loop through the properties, and assign visual settings using index using used: set<number> free: MinHeap<number> Implemebt reusable min heap and nex Index

import {
  PropertyVisualSettings,
  SeriesVisualDimensionConfig,
} from 'src/features/trends/types/visualSettings'

/**
 * Converts combination index to visual style based on chart-specific config
 *
 * Example: Line chart with 18 colors, 3 lineTypes, 3 symbols
 * Priority: ['color', 'lineType', 'symbolType']
 *
 * Index 0: color[0], solid, circle
 * Index 1: color[1], solid, circle
 * Index 2: color[2], solid, circle

 * Index 36: color[0], dotted, circle
 * Index 54: color[0], solid, rect
 */
/**
 * Converts a linear index to a combination of visual settings (color, lineType, symbolType, etc.)
 * according to the provided config's priority and dimension arrays.
 *
 * Edge Cases Handled:
 * - If a dimension in priority is missing from dimensions, it is skipped.
 * - If index exceeds the total number of combinations, the result wraps around (modulo behavior).
 * - Handles any number of dimensions and any order of priority.
 *
 * @param index - Linear index to convert
 * @param config - SeriesVisualDimensionConfig with priority and dimensions
 * @returns PropertyVisualSettings object for the given index
 */
export const indexToCombination = (
  index: number,
  config: SeriesVisualDimensionConfig,
): PropertyVisualSettings => {
  const { priority, dimensions } = config

  // Build arrays of dimension sizes and keys in priority order
  const dimensionSizes: number[] = []
  const dimensionKeys: string[] = []
  for (const dim of priority) {
    if (dim in dimensions) {
      const dimKey = dim as keyof SeriesVisualDimensionConfig['dimensions']
      dimensionSizes.push(dimensions[dimKey].length)
      dimensionKeys.push(dim)
    }
  }

  // Convert linear index to multi-dimensional indices (leftmost varies fastest)
  let remaining = index
  const indices: number[] = []
  for (let i = 0; i < dimensionSizes.length; i++) {
    indices[i] = remaining % dimensionSizes[i]
    remaining = Math.floor(remaining / dimensionSizes[i])
  }

  // Build the visual settings object from indices
  const visualSettings: Partial<PropertyVisualSettings> = {}
  for (let i = 0; i < dimensionKeys.length; i++) {
    const dimKey = dimensionKeys[
      i
    ] as keyof SeriesVisualDimensionConfig['dimensions']
    const dimValue = dimensions[dimKey][indices[i]]
    visualSettings[dimKey] =
      dimValue as unknown as PropertyVisualSettings[typeof dimKey]
  }

  return visualSettings as PropertyVisualSettings
}

/**
 * Calculates the total number of unique visual combinations possible
 * for the given config (product of all dimension lengths in priority).
 *
 * Edge Cases Handled:
 * - If a dimension in priority is missing from dimensions, it is treated as length 1.
 * - If dimensions are empty, returns 1 (single combination).
 *
 * @param config - SeriesVisualDimensionConfig
 * @returns Number of possible combinations
 */
export const getTotalCombinations = (
  config: SeriesVisualDimensionConfig,
): number => {
  const { priority, dimensions } = config
  return priority.reduce((total, dim) => {
    const arr =
      dimensions[dim as keyof SeriesVisualDimensionConfig['dimensions']]
    return total * ((arr && arr.length) || 1)
  }, 1)
}

/**
 * Converts a PropertyVisualSettings object to its corresponding linear index
 * according to the config's priority and dimension arrays.
 *
 * - Fills missing optional visuals from defaults if provided.
 * - Requires 'color' to be present (either in combination or defaults).
 * - Returns -1 if a required value is missing or not found in dimension array.
 * - Works for any config/priority.
 *
 * @param combination - PropertyVisualSettings to convert
 * @param config - SeriesVisualDimensionConfig
 * @param defaults - (optional) object with default values for missing visuals
 * @returns Linear index for the combination, or -1 if invalid
 */
export const combinationToIndex = (
  combination: PropertyVisualSettings,
  config: SeriesVisualDimensionConfig,
  defaults?: Partial<PropertyVisualSettings>,
): number => {
  const { priority, dimensions } = config
  const dimensionSizes: number[] = []
  const indices: number[] = []
  // Required keys (can be extended as needed)
  const requiredKeys = ['color']

  for (const dim of priority) {
    if (!(dim in dimensions)) return -1
    const dimKey = dim as keyof SeriesVisualDimensionConfig['dimensions']
    const values = dimensions[dimKey]
    // Use value from combination, or fallback to defaults if provided
    let value = combination[dimKey]
    if ((value === undefined || value === null) && defaults) {
      // Only assign if not undefined/null, otherwise leave as is for fallback below
      const def = defaults[dimKey]
      value = def !== undefined ? def : null
    }
    // If required key is missing, fail
    if (requiredKeys.includes(dim) && (value === undefined || value === null)) {
      return -1
    }
    // If optional key is missing and no default, skip (treat as first value in dimension)
    if (value === undefined || value === null) {
      // Defensive: always pick a primitive value for fallback
      if (Array.isArray(values) && values.length > 0) {
        // If the dimension is a MultiStateColors array, pick the first string from the first array
        if (Array.isArray(values[0])) {
          const arr = values[0] as unknown[]
          value = typeof arr[0] === 'string' ? arr[0] : null
        } else {
          value = values[0]
        }
      } else {
        value = null
      }
    }
    // Defensive: skip if value is still null/undefined
    if (value === undefined || value === null) return -1
    const idx = values.findIndex((v) => v === value)
    if (idx === -1) return -1 // Value not found in dimension array
    indices.push(idx)
    dimensionSizes.push(values.length)
  }
  // Convert multi-dimensional indices to linear index
  let index = 0
  let multiplier = 1
  for (let i = 0; i < indices.length; i++) {
    index += indices[i] * multiplier
    multiplier *= dimensionSizes[i]
  }
  return index
}
